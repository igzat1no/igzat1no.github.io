<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>theory-of-computation-note-1 | igzat1no&#39;s blog</title>
  <link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="Formal Logical System·
Formal system·


tautology 恒真的 statement
contradiction 恒假的 statement
">
  
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css">
  
  
    <link rel="stylesheet" href="/katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="/katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="/katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
          ],
          throwOnError : false
        });
      });
    </script>
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Posts</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
    <div class="main-nav-space-between"></div>
    
  </nav>
</div>
<div id="header-title">

  
</div>

      <div id="content" class="outer">
        <section id="main"><article id="post-theory-of-computation-note" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/07/theory-of-computation-note/" class="article-date">
  <time class="dt-published" datetime="2022-05-07T17:38:44.000Z" itemprop="datePublished">2022-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      theory-of-computation-note-1
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Formal-Logical-System">Formal Logical System<a class="anchor" href="#Formal-Logical-System">·</a></h2>
<h3 id="Formal-system">Formal system<a class="anchor" href="#Formal-system">·</a></h3>
<ul>
<li><img src="/2022/05/07/theory-of-computation-note/16" alt="image-20220418200944459" loading="lazy"></li>
<li><em><strong>tautology</strong></em> 恒真的 statement</li>
<li><em><strong>contradiction</strong></em> 恒假的 statement</li>
</ul>
<span id="more"></span>
<h3 id="Normal-forms">Normal forms<a class="anchor" href="#Normal-forms">·</a></h3>
<h4 id="Disjunctive-normal-form-or-of-and">Disjunctive normal form (or of and)<a class="anchor" href="#Disjunctive-normal-form-or-of-and">·</a></h4>
<ul>
<li>Every statement form <strong>(not a contradiction)</strong> is logically equivalent to a restricted statement form of the form $\left(\vee_{i=1}<sup>{m}\left(\wedge_{j=1}</sup>{n} Q_{i j}\right)\right)$ where each $Q_{ij}$ is either a variable or the negation of a variable.</li>
</ul>
<h4 id="Conjunctive-normal-form-and-of-or">Conjunctive normal form (and of or)<a class="anchor" href="#Conjunctive-normal-form-and-of-or">·</a></h4>
<ul>
<li>Every statement form <strong>(not a tautology)</strong> is logically equivalent to a restricted statement form of the form $\left(\wedge <em>{i=1}<sup>{m}\left(\vee_{j=1}</sup>{n} Q</em>{i j}\right)\right)$ where each $Q_{ij}$ is either a variable or the negation of a variable.</li>
</ul>
<h3 id="Adequate-set">Adequate set<a class="anchor" href="#Adequate-set">·</a></h3>
<ul>
<li>$\sim$ 加上 ${\wedge,\vee, \rightarrow}$ 中的任何一个</li>
<li>一元的只有 NOR, NAND <span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>必须引入 not<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
<h2 id="Formal-statement-calculus-L">Formal statement calculus(L)<a class="anchor" href="#Formal-statement-calculus-L">·</a></h2>
<ul>
<li>
<p>an alphabet of <strong>symbols</strong>: $\sim, \rightarrow, (, ), P_1, P_2, P_3, \cdots$</p>
</li>
<li>
<p>A set of finite string of these symbols, called <strong>well-formed formula</strong>:</p>
<ul>
<li>$P_i$ is a wf <span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>一个变量是一个式子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>If $A$ and $B$ are wfs, then $(\sim A)$ and $(A \rightarrow B)$ are wfs.</li>
</ul>
</li>
<li>
<p>Axioms:</p>
<ul>
<li><img src="/2022/05/07/theory-of-computation-note/18" alt="image-20220418205040857" loading="lazy"></li>
</ul>
</li>
<li>
<p>rules of deduction</p>
<p><strong>MP</strong>: From $A$ and $A \rightarrow B$,  we can derive $B$</p>
<p><strong>HS</strong>: ${(A\rightarrow B), (B \rightarrow C)} \vdash (A \rightarrow C)$</p>
</li>
</ul>
<h3 id="Deduction-Theorem">Deduction Theorem<a class="anchor" href="#Deduction-Theorem">·</a></h3>
<ul>
<li>$\Delta \cup {A} \vdash B \Leftrightarrow \Delta \vdash A \rightarrow B$</li>
<li>Proof: 归纳推导过程的长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>枚举最后一步推导的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>substitution or MP</li>
</ul>
<h1 id="Unfinished-some-examples">Unfinished! some examples<a class="anchor" href="#Unfinished-some-examples">·</a></h1>
<ul>
<li><img src="/2022/05/07/theory-of-computation-note/20" alt="image-20220418224906806" loading="lazy"></li>
</ul>
<h2 id="Extension">Extension<a class="anchor" href="#Extension">·</a></h2>
<ul>
<li>
<p>An extension L<em>of L is <strong>consistent</strong> if and only if there is a wf. which is not a theorem of L</em>.</p>
<ul>
<li>
<p>Otherwise</p>
<p><img src="/2022/05/07/theory-of-computation-note/19" alt="image-20220418224550276" loading="lazy"></p>
</li>
</ul>
</li>
<li>
<p><strong>complete</strong>: we can decide every statement true or false</p>
</li>
<li></li>
</ul>
<h2 id="Turing-Machines">Turing Machines<a class="anchor" href="#Turing-Machines">·</a></h2>
<h3 id="Standard-Turing-Machine">Standard Turing Machine<a class="anchor" href="#Standard-Turing-Machine">·</a></h3>
<ul>
<li>input $w$ is written on the first $|w|$ cells, other cells are empty</li>
<li><strong>when want to move to the left of the leftmost cell, stay put</strong></li>
<li>At each time
<ul>
<li>read the symbol</li>
<li>write a symbol</li>
<li>move left or right</li>
</ul>
</li>
<li><img src="/2022/05/07/theory-of-computation-note/1.png" alt="image-20220404110144013" loading="lazy"></li>
<li>A language is <em><strong>recursively enumerable (recognizable)</strong></em> if some TM recognizes it.
<ul>
<li>the TM can enumerate all the strings</li>
</ul>
</li>
<li>A language is <em><strong>recursive (decidable)</strong></em> if some TM decides it.
<ul>
<li><em><strong>recursive language $\subset$ recursively enumerable language</strong></em></li>
</ul>
</li>
</ul>
<h3 id="Multiple-Tapes">Multiple Tapes<a class="anchor" href="#Multiple-Tapes">·</a></h3>
<h4 id="2-Tape-Turing-Machine">2-Tape Turing Machine<a class="anchor" href="#2-Tape-Turing-Machine">·</a></h4>
<ul>
<li>The input is on Tape 1.</li>
<li>Tape 2 is initially blank.</li>
<li>Read a symbol from each tape, each head moves. 两个一起动</li>
</ul>
<h5 id="Simulation-on-one-TM">Simulation on one TM<a class="anchor" href="#Simulation-on-one-TM">·</a></h5>
<ul>
<li>
<p>each $a \in \Gamma$ has a mirror state $a ^ *$</p>
<p>if one state has $*$  it means 当前 head 位于这个位置</p>
</li>
<li>
<p>Beginning</p>
<ul>
<li>input#$\perp^*$</li>
<li>replace the first symbol $a$ with $a ^ *$
<ul>
<li>表示 一开始 第一个纸带 输入是input 位置在第一位</li>
<li>第二个纸带 输入是空 位置在第一位</li>
<li>中间用 # 隔开</li>
</ul>
</li>
<li>每一次在一个上面做完了 就找到另一个 $*$ state 然后再做</li>
<li>special case: 如果第一个纸带做到了 # 上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>先整体右移</li>
</ul>
</li>
</ul>
<h3 id="Nondeterministic-Turing-Machine">Nondeterministic Turing Machine<a class="anchor" href="#Nondeterministic-Turing-Machine">·</a></h3>
<ul>
<li>下一个状态是一个可行集合</li>
<li>只要有可行的方式到达 accept 那就是 accept</li>
<li>simulate 的方式
<ul>
<li>3-tape TM
<ul>
<li>tape 1: input</li>
<li>tape 2: simulate</li>
<li>tape 3: 按从短到长的顺序 存储 guess (bfs)</li>
</ul>
</li>
<li>每次把 1 里面的 input load 到 2 上去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前 3 的 guess 在 2 上跑一遍</li>
</ul>
</li>
<li>a NTM is a <em><strong>decider</strong></em> if all branches halt on all inputs</li>
</ul>
<h3 id="TM-with-outputs">TM with outputs<a class="anchor" href="#TM-with-outputs">·</a></h3>
<ul>
<li>TM with a write only tape</li>
<li><em><strong>enumerator</strong></em>
<ul>
<li>a machine that can enumerate strings one by one, maybe with repetitions</li>
<li>为什么 Turing recognizable 的 language 称作 recursively enumerable
<ul>
<li>因为可以用一个enumerator E 去 generate</li>
<li><img src="/2022/05/07/theory-of-computation-note/6.png" alt="image-20220412171050992" loading="lazy"></li>
<li>为啥得枚举 步数
<ul>
<li>一个 TM 输入的串的长度是否确定了在TM 上运行时间的上界</li>
</ul>
</li>
<li>如何recognize
<ul>
<li>每次枚举出来一个 就跟输入 w 比较</li>
<li>accept的总能判断出来 但 reject 的可能会不停机</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Universal-Turing-Machine-UTM">Universal Turing Machine (UTM)<a class="anchor" href="#Universal-Turing-Machine-UTM">·</a></h3>
<ul>
<li>the set of TM is countable
<ul>
<li>可以编号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用 &lt;M&gt; 代表第 M 这个 $TM$ 的编号</li>
</ul>
</li>
<li>UTM
<ul>
<li>input: M, w</li>
<li>output: 与 M 上跑 w 的结果一样</li>
</ul>
</li>
</ul>
<h2 id="Halting-Problem">Halting Problem<a class="anchor" href="#Halting-Problem">·</a></h2>
<h3 id="A-TM">$A_{TM}$<a class="anchor" href="#A-TM">·</a></h3>
<ul>
<li>$A_{T M}={&lt;M, w&gt;\mid M \text { is a TM and } M \text { accepts } w}$</li>
<li>want to prove $A_{TM}$ is not decidable</li>
<li>Proof:
<ul>
<li>If $A_{TM}$ is decidable
<ul>
<li>$\exist H$ that decides $A_{TM}$</li>
<li>consider $H(M, <M>)$
<ul>
<li>accept if $M$ accepts $<M>$</li>
<li>reject if $M$ rejects or loops on $<M>$</li>
<li>always halt</li>
</ul>
</li>
<li>令 $D(<M>)$ 如下定义 <span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>也是一个 TM<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>
<ul>
<li><img src="/2022/05/07/theory-of-computation-note/7" alt="image-20220412173857875" loading="lazy"></li>
<li>always halt</li>
</ul>
</li>
<li>考虑 $D(<D>)$
<ul>
<li>$D$ accept $<D>$ -&gt; $H(D, <D>)$ reject -&gt; $D$ reject or loop on $<D>$</li>
<li>$D$ reject $<D>$ -&gt; $H(D, <D>)$ accept -&gt; $D$ accept $<D>$</li>
<li>总是矛盾</li>
</ul>
</li>
</ul>
</li>
<li>Thus, $A_{TM}$ is not decidable</li>
</ul>
</li>
<li>显然 $A_{TM}$ is recognizable 因为我们可以直接模拟</li>
<li>所以 $A_{TM}$ is not co-recognizable</li>
</ul>
<h3 id="HALT-TM">$HALT_{TM}$<a class="anchor" href="#HALT-TM">·</a></h3>
<ul>
<li>
<p>$\mathrm{HALT}_{\mathrm{TM}}={&lt;M, w&gt;\mid \text{TM } M \text { halts on input } w&gt;$</p>
</li>
<li>
<p>not decidable</p>
</li>
<li>
<p>recognizable</p>
</li>
<li>
<p>not co-recognizable</p>
</li>
</ul>
<h2 id="Turing-reducibility">Turing reducibility<a class="anchor" href="#Turing-reducibility">·</a></h2>
<h3 id="Oracle-Turing-Machine-OTM">Oracle Turing Machine (OTM)<a class="anchor" href="#Oracle-Turing-Machine-OTM">·</a></h3>
<ul>
<li>相当于你有一个 oracle language A 就是有一个 tool A</li>
<li>你可以询问 A 让他自己告诉你 询问的串 在不在 $A$ 中</li>
</ul>
<h3 id="Definition">Definition<a class="anchor" href="#Definition">·</a></h3>
<ul>
<li>
<p>Language A is Turing reducible to B, if an oracle TM $M^B$</p>
<p>decides A, write $A\leq _T B$</p>
</li>
<li>
<p>就是说 有了 $B$ <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>$A$ 就是 turing decidable</p>
</li>
<li>
<p>Ex: $A_{TM} \leq_T HALT_{TM}$</p>
</li>
</ul>
<h3 id="Examples">Examples<a class="anchor" href="#Examples">·</a></h3>
<ol>
<li>
<p>$E_{TM} = {\langle M \rangle \mid M 是一个图灵机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 L(M) = \emptyset}$</p>
<p><em><strong>Undecidable</strong></em></p>
<p><img src="/2022/05/07/theory-of-computation-note/8" alt="image-20220412182018250" loading="lazy"></p>
</li>
<li>
<p>$REGULAR_{TM} = {\langle M \rangle \mid M 是一个图灵机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 L(M) 是一个正则语言}$</p>
<p><em><strong>Undecidable</strong></em></p>
<p><img src="/2022/05/07/theory-of-computation-note/9" alt="image-20220412193319580" loading="lazy"></p>
</li>
<li>
<p>$E Q_{\mathrm{TM}}=\left{\left\langle M_{1}, M_{2}\right\rangle \mid M_{1}\right.$ 和 $M_{2}$ 都是图灵机, 且 $\left.L\left(M_{1}\right)=L\left(M_{2}\right)\right}$</p>
<p><em><strong>Undecidable</strong></em></p>
<p>If $EQ_{TM}$ is decidable,</p>
<p>令 $M_1$ 是一个拒绝所有输入的图灵机</p>
<p>对于 $M$<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>输入 $\langle M, M_1\rangle$  $EQ_{TM}$ 即判定 $L(M)$ 是否为空</p>
<p>解决了 $E_{TM}$</p>
</li>
</ol>
<h4 id="Properties-of-CFG">Properties of CFG<a class="anchor" href="#Properties-of-CFG">·</a></h4>
<p><img src="/2022/05/07/theory-of-computation-note/10" alt="image-20220412193401901" loading="lazy"></p>
<h3 id="Reduction-via-Computation-History">Reduction via Computation History<a class="anchor" href="#Reduction-via-Computation-History">·</a></h3>
<h4 id="Definition-of-computation-history">Definition of computation history<a class="anchor" href="#Definition-of-computation-history">·</a></h4>
<ul>
<li>
<p>Let $M$ be a TM and $w$ be an input string.</p>
<p>An <em><strong>accepting computation history</strong></em> for $M$ on $w$ is a sequence of configurations, $C_1, C_2, \cdots, C_l$ , where $C_1$ is the start configuration of $M$ on $w$, $C_l$ is an accepting configuration of $M$, and each $C_i$ legally follows from $C_{i−1}$ according to the rules of $M$.</p>
<p>A <em><strong>rejecting computation history</strong></em> for $M$ on $w$ is defined similarly, except that $C_l$ is a rejecting configuration.</p>
<p>一个 configuration $C_i$ 是指 形如 $u a q_i b v$ 的组合 包含了带子的内容 头的位置和状态信息</p>
</li>
<li>
<p>计算历史 是有限序列</p>
<p>如果不停机 那么不存在计算历史</p>
</li>
</ul>
<h4 id="Example-Linear-bounded-automaton-LBA">Example: Linear bounded automaton (LBA)<a class="anchor" href="#Example-Linear-bounded-automaton-LBA">·</a></h4>
<ul>
<li>
<p>LBA 是一种图灵机 不允许 head 离开 input 在带子上的区域</p>
</li>
<li>
<p>相当于 纸带的存储大小被 input bound 住</p>
</li>
<li>
<p>$A_{LBA} = {\langle M, w\rangle \mid M是一个接受w的LBA}$</p>
</li>
<li>
<p>Lemma: Let $M$ be an $LBA$ with $q$ states and $g$ symbols in the tape alphabet. There are exactly $qng^n$ distinct configurations of $M$ for a tape of length $n$.</p>
<p>configuration数有限 显然</p>
</li>
<li>
<p>$A_{LBA}$ is decidable</p>
<ul>
<li>因为 configuration 的上限 is $qng^n$ 我们可以在 w 上 模拟这么多步 或者直到它停机</li>
<li>如果接受就接受 如果拒绝或者还没跑完就拒绝</li>
</ul>
</li>
<li>
<p>$E_{LBA}$ is not decidable</p>
<ul>
<li>想要从 $E_{LBA}$ 规约到 $A_{TM}$</li>
<li>对于 $M$ 和 $w$ 我们构造一个检查器 检查器的输入是 $M, w$ 以及一段 accepting computation history</li>
<li>检查器就是检查 computation history 是否合法 显然不需要额外的空间 因此是 LBA</li>
<li>我们只要判断是否属于 $E_{LBA}$ 也就是判断了 是否存在 accepting computation history</li>
</ul>
</li>
</ul>
<h4 id="Example-ALL-CFG">Example: $ALL_{CFG}$<a class="anchor" href="#Example-ALL-CFG">·</a></h4>
<ul>
<li>
<p>$ALL_{CFG}$ is not decidable</p>
<ul>
<li>
<p>想要从 $ALL_{CFG}$ 规约到 $A_{TM}$</p>
</li>
<li>
<p>构造一个非确定的 PDA 对于 M 和 w</p>
<ul>
<li>如果 M 接受 w 则 PDA 不能接受所有的串
<ul>
<li>不接受 M 中 w 的 accepting history<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span></li>
</ul>
</li>
<li>如果 M 不接受 w 则 PDA 能够接受所有的串</li>
</ul>
</li>
<li>
<p>所以只要构造这样的PDA 不接受 w 的 accepting history 其他均接受</p>
</li>
<li>
<p>接受以下所有</p>
</li>
<li>
<ol>
<li>不以 $C_1$ 开始</li>
<li>不以一个 accepting configuration 结束</li>
<li>某个 $C_i$ 不能派生 $C_{i+1}$</li>
</ol>
</li>
<li>
<p>PDA 也有三个分支分别对应三种情况</p>
<ul>
<li>
<ol>
<li>
<p>不以 $C_1$ 开始就接受</p>
</li>
<li>
<p>不以 accepting 结束 就接受</p>
</li>
<li>
<p>一个个判断</p>
<p>在判断 $C_i$ 到 $C_{i+1}$ 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>首先走到 $C_i$ 然后将其压入栈</p>
<p>然后与 $C_{i+1}$ 一点点比较<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>除了读写头之外应该相同</p>
<p>读写头部分用 $M$ 去判断是否合理</p>
</li>
</ol>
<blockquote>
<p>一个小问题 是 压入栈之后顺序会颠倒<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前一个倒着后一个正着 不能一个个比较</p>
<p>解决方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>把奇数位置的串正着写 偶数位置的倒着写</p>
<p><img src="/2022/05/07/theory-of-computation-note/11" alt="image-20220412234303769" loading="lazy"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Post-correspondence-problem-PCP">Post correspondence problem (PCP)<a class="anchor" href="#Post-correspondence-problem-PCP">·</a></h4>
<ul>
<li>七种block
<ul>
<li>开始的block [# | #$q_0w_1w_2\cdots w_n$#]</li>
<li>如果 $\delta(q, a) = (r, b, R)$<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span> 加入 [$qa$ | $br$]</li>
<li>如果 $\delta(q,a) = (r, b, L)$<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span> 加入 [$cqa$ | $rcb$] $(\forall c)$</li>
<li>加入 $[a | a]$ $(\forall a)$</li>
<li>[# | #], [# | $\epsilon$#]</li>
<li>[$aq_{accept}$ | $q_{accept}$], [$q_{accept}a$ | $q_{accept}$] 用来蚕食最后的剩余的骨牌们</li>
<li>[$q_{accept}$## | #] 最后位置上的匹配</li>
</ul>
</li>
<li>如何强制让第一种排在第一位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后一种排在最后一位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>
<ul>
<li><img src="/2022/05/07/theory-of-computation-note/12" alt="image-20220414154826455" loading="lazy"></li>
<li>这样 只有第一个是开头都是星星</li>
<li>只有最后一个结尾都是方块</li>
</ul>
</li>
</ul>
<h3 id="Mapping-reducibility">Mapping reducibility<a class="anchor" href="#Mapping-reducibility">·</a></h3>
<h4 id="Definition-2">Definition<a class="anchor" href="#Definition-2">·</a></h4>
<ul>
<li>A function is <em><strong>computable / recursive</strong></em> if some TM $M$, on every input $w$, halts with $f(w)$.</li>
<li>Language $A$ is <em><strong>mapping reducible</strong></em> to language $B$ if there is a recursive function $f$ s.t. $w\in A \Leftrightarrow f(w) \in B$.</li>
</ul>
<h4 id="Properties">Properties<a class="anchor" href="#Properties">·</a></h4>
<ul>
<li>If $A \leq _m B$ and $B$ is decidable, then $A$ is decidable.</li>
<li>If $A \leq _m B$ and $B$ is recognizable, then $A$ is recognizable.</li>
<li>If $A \leq _m B$ and $B$ is co-recognizable, then $A$ is co-recognizable.</li>
</ul>
<h4 id="Example">Example<a class="anchor" href="#Example">·</a></h4>
<ul>
<li>Prove $EQ_{TM}$ is not decidable, recognizable, co-recognizable.</li>
<li>not decidable:
<ul>
<li>proved by Turing reduction</li>
<li>规约到 $A_{TM}$ 是否与一个 空的TM 相同</li>
</ul>
</li>
<li>not recognizable:
<ul>
<li><img src="/2022/05/07/theory-of-computation-note/13" alt="image-20220414163247206" loading="lazy"></li>
<li>$A_{TM}$ is not co-recognizable, so $EQ_{TM}$ is not recognizable.</li>
</ul>
</li>
<li>not co-recognizable:
<ul>
<li>类似</li>
</ul>
</li>
</ul>
<h4 id="Difference-with-Turing-reducibility">Difference with Turing reducibility<a class="anchor" href="#Difference-with-Turing-reducibility">·</a></h4>
<ul>
<li>
<p>更强</p>
</li>
<li>
<p>需要是同向的</p>
</li>
<li>
<p>性质一样 因为能够用一个 $f$ 去 map</p>
</li>
<li>
<p>Turing-reduction only for proving undecidability, and mapping-reduction can be used for prove unrecognizability.</p>
</li>
</ul>
<h2 id="Recursion-Theorem">Recursion Theorem<a class="anchor" href="#Recursion-Theorem">·</a></h2>
<ul>
<li>Let $t: N \rightarrow N$ be a recursive function. There is a TM $F$ for which $t(\langle F\rangle)$ is the code of a Turing machine equivalent to $F$.</li>
</ul>
<h3 id="Proof">Proof<a class="anchor" href="#Proof">·</a></h3>
<ul>
<li>define such a TM $D$:</li>
</ul>
<pre><code>  D(&lt;M&gt;):
   output the code of the TM:
   G(y):
    d = M(&lt;M&gt;)
    simulate the machine with code d on y
</code></pre>
<ul>
<li>
<p>$D$ is recursive because 只是输出一个编号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不用运行 $G$</p>
</li>
<li>
<p>define a TM $V$:</p>
</li>
</ul>
<pre><code>  V(&lt;M&gt;):
   output t(D(&lt;M&gt;))
</code></pre>
<ul>
<li>
<p>Let $\langle F \rangle = D(\langle V \rangle)$</p>
</li>
<li>
<p>Then when running $F(y)$:</p>
<ul>
<li><code>d = V(&lt;V&gt;) = t(D(&lt;V&gt;)) = t(&lt;F&gt;)</code></li>
<li><code>simulate the machine with code d on y</code></li>
</ul>
</li>
<li>
<p>So <code>F(y) = simulating the TM with code t(&lt;F&gt;) on y</code></p>
</li>
</ul>
<h3 id="Diagonalized-Proof">Diagonalized Proof<a class="anchor" href="#Diagonalized-Proof">·</a></h3>
<ul>
<li><img src="/2022/05/07/theory-of-computation-note/15" alt="image-20220415172903423" loading="lazy"></li>
<li>Unfinished</li>
</ul>
<h3 id="Generalization-Kleene’s-recursion-theorem">Generalization: Kleene’s recursion theorem<a class="anchor" href="#Generalization-Kleene’s-recursion-theorem">·</a></h3>
<ul>
<li>Let $t$ be a recursive function $t: N \times N \rightarrow N$. There is a Turing machine $R: N \rightarrow N$, where $R(x)=t(\langle R\rangle, x)$</li>
</ul>
<h4 id="Proof-2">Proof<a class="anchor" href="#Proof-2">·</a></h4>
<ul>
<li>Define a recursive function $s: N \rightarrow N$ by s-m-n thm:</li>
</ul>
<pre><code>  s(x):
   output the code of TM on input y computing t(x,y)
</code></pre>
<ul>
<li>
<p>By recursion theorem on $s$, we have a TM $F$ s.t. the TM with code $s(\langle F\rangle)$ is equivalent to $F$.</p>
</li>
<li>
<p>The TM with code $s(\langle F \rangle)$ is the TM that computes $t(x,y)$ on input $y$.</p>
</li>
</ul>
<h1 id="Unfinished">Unfinished<a class="anchor" href="#Unfinished">·</a></h1>
<h2 id="Kolmogorov-complexity">Kolmogorov complexity<a class="anchor" href="#Kolmogorov-complexity">·</a></h2>
<h3 id="Definition-3">Definition<a class="anchor" href="#Definition-3">·</a></h3>
<ul>
<li>Let $x$ be a binary string.</li>
<li>The <em><strong>minimum description</strong></em> $d(x)$ of $x$ is the shortest string $&lt;M,w&gt;$ where TM $M$ on input $w$ halts with $x$ on the tape.</li>
<li>The <em><strong>Kolmogorov complexity</strong></em> $K(x)=|d(x)|$</li>
<li>串 $x$ 的信息量</li>
</ul>
<h3 id="Properties-2">Properties<a class="anchor" href="#Properties-2">·</a></h3>
<ul>
<li>$\forall x$, $K(x) \leq |x| + c$, for some constant $c$.</li>
<li>$\forall x$, $K(xx) \leq |x| + c$, for some constant $c$.</li>
<li>$\forall x$, $K(x ^ n) \leq |x| + c \log n$, for some constant $c$.
<ul>
<li>存储 $n$<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个bound是 $\log n + c$</li>
<li>任何的图灵机 都是固定长度的 除了输入的部分</li>
</ul>
</li>
</ul>
<h3 id="c-compressible">c-compressible<a class="anchor" href="#c-compressible">·</a></h3>
<ul>
<li>
<p>A string $x$ is <em><strong>c-compressible</strong></em> if $K(x) \leq |x| - c$.</p>
</li>
<li>
<p>If $x$ is not <em><strong>1-compressible</strong></em>, then $x$ is <em><strong>incompressible</strong></em>.</p>
</li>
<li>
<p><strong>Thm: Incompressible strings of every length exist.</strong></p>
<ul>
<li>Proof: 为什么只用 二进制串的 description</li>
</ul>
</li>
<li>
<p><strong>Thm:</strong> $\forall n, c$, $\operatorname{Pr}_{x \in{0,1}^{n}}[K(x) \geq|x|-c] \geq 1-\frac{1}{2^{c}}$</p>
<ul>
<li>Proof: 一样考虑二进制的 description 的个数</li>
</ul>
</li>
</ul>
<h3 id="Compressibility">Compressibility<a class="anchor" href="#Compressibility">·</a></h3>
<ul>
<li>
<p>$COMPRESS = {(x, c) \mid K(x) \leq c}$</p>
</li>
<li>
<p><strong>Thm: COMPRESS is undecidable.</strong></p>
<p>Proof:</p>
<ul>
<li>
<p>Construct a Machine M:</p>
<pre><code>M(n):
 For all y in 字典序&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;：&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;
  if (y, n) \notin COMPRESS
   print y
   halt
</code></pre>
</li>
<li>
<p>Then we get $y$, the first string of $K(y) &gt; n$</p>
</li>
<li>
<p>但是 $M(n)$ prints y, $K(y) \leq |\langle M, n\rangle | = c + \log n$</p>
</li>
<li>
<p>当 $n$ 充分大时矛盾</p>
</li>
</ul>
</li>
</ul>
<h3 id="Chaitin’s-incompleteness-theorem">Chaitin’s incompleteness theorem<a class="anchor" href="#Chaitin’s-incompleteness-theorem">·</a></h3>
<ul>
<li>
<p><img src="/2022/05/07/theory-of-computation-note/14" alt="image-20220415165729111" loading="lazy"></p>
</li>
<li>
<p>Proof:</p>
<ul>
<li>
<p>Suppose we can prove $K(x) &gt; L$ for some $x$.</p>
</li>
<li>
<p>选择 proof 的长度最小的 $P$ which proves $K(y) &gt; L$.</p>
</li>
<li>
<p>考虑这样一个图灵机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<pre><code>R(L):
 枚举所有的argument Q&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;：&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;
  check whether Q is valid
  check whether Q proves K(y) &gt; L
  If yes, outputs y
</code></pre>
<p>这样一个玩意儿的长度是 $|\langle R, L\rangle| = c + \log L$<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与 $K(y) &gt; L$ 矛盾</p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>不需要输入 y 嘛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>虽然不影响证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
</li>
</ul>
</li>
</ul>
<h2 id="“Were-you-last”-Game">“Were-you-last” Game<a class="anchor" href="#“Were-you-last”-Game">·</a></h2>
<ul>
<li>m players, unlimited bits</li>
<li>each player can read/write $\leq t$ bits</li>
</ul>
<h3 id="Solution">Solution<a class="anchor" href="#Solution">·</a></h3>
<h4 id="Trivial-solution">Trivial solution<a class="anchor" href="#Trivial-solution">·</a></h4>
<ul>
<li>Counter</li>
</ul>
<pre><code>  If Counter = 0, Counter = m
  Else Counter -= 1
</code></pre>
<ul>
<li>$t = O(\log m)$</li>
</ul>
<h4 id="real-solution">real solution<a class="anchor" href="#real-solution">·</a></h4>
<ul>
<li>use several blocks to represent the counter
<ul>
<li>type of last block 0 / 1</li>
<li>number of blocks</li>
<li>size of each block</li>
</ul>
</li>
<li>$t \leq 4 \log \log m + O(1)$</li>
<li>How to set the initial counter to m?
<ul>
<li>work on $C’ = C \oplus  m$</li>
</ul>
</li>
<li>Lower bound of $t$: $0.4 \log \log m$</li>
<li>Cannot be solved when $t = o(\log\log m)$
<ul>
<li>无论玩家什么策略<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义 $S_i$ 表示 $i$ 这个玩家可能修改的 bits 的集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>均有 $|S_i| \leq 2 ^ t - 1$<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于决策树最多 $t$ 层<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>至多可以看 t 个 bit<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每层最多两个选择<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>当前看的 bit 是 0/1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>如果玩家的策略均相同
<ul>
<li>$\forall i, S_i = S$</li>
<li>$|S| &lt; \log m$<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不足以表示 $0\sim m-1$</li>
</ul>
</li>
<li>如果玩家策略不同
<ul>
<li>Sunflower Lemma
<ul>
<li>A sunflower: 一堆集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有共同的交集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其他部分两两不交</li>
<li>Let $S_1, \cdots, S_m$ be a collection of sets each of size $\leq l$. If $m &gt; (p - 1) ^ {l+1} l!$, then 存在一个包含p个集合的 sunflower</li>
</ul>
</li>
<li>取 $l = 2 ^ t - 1$, $m &gt; (p-1) ^ {l+1} l!$</li>
<li>存在一个 $p$ 的 sunflower<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记为 $S_1, \cdots, S_p$</li>
<li>首先搞定其他所有的人<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后这 p 个人放到最后操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只有 center of sunflower 会有影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>center 的 size $\leq l$</li>
<li>center 的状态 $\leq 2 ^ l$<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果 $p &gt; 2 ^ l$<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们有 至少两个人 面对相同的 center 状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设为 $i$ 和 $j$</li>
<li>假设 $i$ 出现在 $j$ 之前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把 $i\sim j - 1$ 删掉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么对于 $j$ 之后的人没有影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>原先的最后一个人仍旧会判断自己为最后一个人<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>错误</li>
<li>$(2 ^ l) ^ {l+1} l! \leq 2 ^ {l ^ 2 + l + l\log l} &lt; m$ 合理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Bounds-of-Complexity">Bounds of Complexity<a class="anchor" href="#Bounds-of-Complexity">·</a></h2>
<ul>
<li>$O$ 上界 $\Omega$ 下界</li>
<li>基于比较的排序的复杂度
<ul>
<li>决策树</li>
</ul>
</li>
</ul>
<h2 id="Dynamic-Partial-Sum">Dynamic Partial Sum<a class="anchor" href="#Dynamic-Partial-Sum">·</a></h2>
<h3 id="Description">Description<a class="anchor" href="#Description">·</a></h3>
<ul>
<li>单点修改</li>
<li>求前缀和</li>
</ul>
<h3 id="Bound-of-complexity">Bound of complexity<a class="anchor" href="#Bound-of-complexity">·</a></h3>
<ul>
<li>
<p>线段树 复杂度 查询修改均为 $O(\log n)$</p>
</li>
<li>
<p><img src="/2022/05/07/theory-of-computation-note/21" alt="image-20220419012141083" loading="lazy"></p>
</li>
</ul>
<h4 id="Interleave-info-IL">Interleave info(IL)<a class="anchor" href="#Interleave-info-IL">·</a></h4>
<ul>
<li>
<p>$IL(t_0, t_1, t_2)$ 表示 $(t_0,t_1)$ 向 $(t_1,t_2)$ 传递信息的次数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>只考虑 $t1 - t_0 = t_2 - t_1$<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
</li>
<li>
<p>$IL(t_0, t_1, t_2)$ is the number of transitions between a value $\pi(i)$ with $i&lt;t_1$, and a consecutive value $\pi(j)$ with $j&gt;t_1$</p>
</li>
<li>
<p>$E[IL(t_0, t_1, t_2)]$</p>
<ul>
<li>$\operatorname{Pr}\left[\mathrm{j}\right.$ is in $\left.\left[\mathrm{t}<em>{0}, \mathrm{t}</em>{1}\right]\right]=\mathrm{k} /(2 \mathrm{k})=1 / 2$</li>
<li>$\operatorname{Pr}\left[j+1\right.$ is in $\left[t_{1}, t_{2}\right] \mid$ j is in $\left.\left[t_{0}, t_{1}\right]\right]=k /(2 k-1)$</li>
<li>$\mathrm{E}\left[\mathrm{IL}\left(\mathrm{t}<em>{0}, \mathrm{t}</em>{1}, \mathrm{t}_{2}\right)\right]=(2 k-1) \cdot \frac{k}{2(2 k-1)}=\frac{k}{2}$</li>
</ul>
</li>
<li>
<h1 id="Unfinished-bound">Unfinished bound<a class="anchor" href="#Unfinished-bound">·</a></h1>
</li>
</ul>
<h4 id="Information-transfer-IT">Information transfer (IT)<a class="anchor" href="#Information-transfer-IT">·</a></h4>
<ul>
<li>$IT(t_0, t_1, t_2)$ 表示 在 $(t_0, t_1)$ 写 在 $(t_1, t_2)$ 读 且 在 $(t_1, t_2)$ 不再写 的 memory locations 的集合</li>
<li><img src="/2022/05/07/theory-of-computation-note/22" alt="image-20220419014418611" loading="lazy"></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
        <a href="/2022/05/07/theory-of-computation-note/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2022/05/07/theory-of-computation-note/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lecture-Note/" rel="tag">Lecture Note</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Theory-of-computation/" rel="tag">Theory of computation</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/05/19/git-useful-commands/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          git-useful-commands
        
      </div>
    </a>
  
  
    <a href="/2022/05/04/Deep-Learning-notes/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          Deep Learning Lecture notes
        
      </div>
    </a>
  
</nav>

  
</article>



  <section id="comments" class="vcomment">

  </section>
</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        <span id="busuanzi_container_site_pv" style='display:none'>Total view count: <span id="busuanzi_value_site_pv"></span></span>
<p>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/bill-xia/hexo-theme-mashiro">Mashiro</a> & GitHub Pages</p><p>Copyright © 2024 igzat1no. LICENSE CC BY-NC-SA 4.0.</p>
      
    </div>
  </div>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Posts</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="/js/clipboard.min.js"></script>
<script src="/js/jquery-1.4.3.min.js"></script>

<script src="/fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="/js/script.js"></script>




  
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

<script>
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
        return GUEST_INFO.indexOf(item) > -1
    });
    var notify = 'false' == true;
    var verify = 'false' == true;
    new Valine({
        el: '.vcomment',
        notify: notify,
        verify: verify,
        appId: "k2JFn7Fvw42zZfjmoYffhjGC-gzGzoHsz",
        appKey: "pLfzf8qWKmVAAZPSJ0fXlTlg",
        placeholder: "Leave your footprints here!!",
        pageSize:'10',
        avatar:'wavatar',
        lang:'zh-cn'
    });
</script>



  </div>
</body>
</html>